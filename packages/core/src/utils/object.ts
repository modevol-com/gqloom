import type {
  GraphQLArgument,
  GraphQLArgumentConfig,
  GraphQLFieldConfig,
  GraphQLFieldMap,
} from "graphql"

/**
 * Creates an object map with the same keys as `map` and values generated by
 * running each value of `record` thru `fn`.
 */
export function mapValue<T, V>(
  record: Record<string, T>,
  fn: (value: T, key: string) => V | typeof mapValue.SKIP
): Record<string, V> {
  const result = Object.create(null)

  for (const key of Object.keys(record)) {
    const value = fn(record[key], key)
    if (value === SKIP) continue
    result[key] = value
  }
  return result
}

const SKIP = Symbol.for("mapValue.skip")
mapValue.SKIP = SKIP

export function toObjMap<T>(
  obj: Readonly<Record<string, T>> | null | undefined
): Record<string, T> {
  if (obj == null) {
    return Object.create(null)
  }

  if (Object.getPrototypeOf(obj) === null) {
    return obj
  }

  const map = Object.create(null)
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value
  }
  return map
}

export function notNullish<T>(x: T | undefined | null): x is T {
  return x != null
}

export function toArguments(
  map: Record<string, GraphQLArgumentConfig>
): ReadonlyArray<GraphQLArgument> {
  return Object.entries(map).map(([name, argConfig]) => ({
    name,
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode,
  }))
}

export function toFieldMap(
  fields: Record<string, GraphQLFieldConfig<any, any>>
): GraphQLFieldMap<any, any> {
  const result: GraphQLFieldMap<any, any> = Object.create(null)

  for (const [fieldName, fieldConfig] of Object.entries(fields)) {
    const argsConfig = fieldConfig.args ?? {}
    result[fieldName] = {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: toArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode,
    }
  }

  return result
}

export function deepMerge<T extends Record<string, any>>(
  ...objects: (T | null | undefined)[]
): T {
  const result = {} as any

  for (const obj of objects) {
    if (obj == null) continue
    for (const [key, value] of Object.entries(obj)) {
      if (value !== null && typeof value === "object") {
        if (Array.isArray(value)) {
          if (!Array.isArray(result[key])) {
            result[key] = []
          }
          result[key] = [...result[key], ...value]
        } else {
          result[key] = deepMerge(result[key] as any, value)
        }
      } else {
        result[key] = value
      }
    }
  }

  return result
}

/**
 * Wraps the provided data in an object with a single key `"~meta"`.
 *
 * @template T - The type of the data to be wrapped.
 * @param {T} data - The data to be wrapped.
 * @returns {{ "~meta": T }} - An object with a single key `"~meta"` containing the provided data.
 * @example
 * const originalData = { key: "value" };
 * const metaData = meta(originalData);
 * console.log(metaData); // Output: { "~meta": { key: "value" } }
 */
export function meta<T>(data: T): { "~meta": T } {
  return { "~meta": data }
}
